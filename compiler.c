#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "compiler.h"
#include "parser.h"
#include "lexer.h"
#include "io.h"
#include "hashmap.h"

#define COMPILE_PART_PREMAIN 0
#define COMPILE_PART_MAIN 1

#define append(A, B) {A = appendString(A, B);}
#define concat(A, B) {append(parts[A], B);}

void findFunctionType(Function *function){
	function->type = INT;
}

void findVariableType(Variable *variable){
	variable->type = INT;
}

Function *createFunction(TreeNode* start, TreeNode* stmtlist, TreeNode* args){
	Function *f = malloc(sizeof(Function));
	f->start = start;
	f->stmtlist = stmtlist;
	f->arguments = args;
	findFunctionType(f);
	return f;
}

Variable *createVariable(TreeNode *start, TreeNode *name, TreeNode *value){
	Variable *v = malloc(sizeof(Variable));
	v->start = start;
	v->name = name;
	v->value = value;
	v->container = NULL;
	findVariableType(v);
	return v;
}

char* variableToString(Variable *v){
	char* str = malloc(1 * sizeof(char));
	str[0] = '\0';
	append(str, valueTypeToString(v->type));
	append(str, strdup(" "));
	append(str, strdup(v->name->data->text));
	append(str, strdup("="));
	append(str, strdup("5"));
	append(str, strdup(";"));
	return str;
}

char* valueTypeToString(ValueType type){
	char* str = malloc(32);
	switch(type){
		case INT:
			sprintf(str, "%s", strdup("int"));
			break;
		case VOID:
			sprintf(str, "%s", strdup("void"));
			break;
		case FUNCTION:
			sprintf(str, "%s", strdup("int*"));
			break;
		default:
			sprintf(str, "%s", strdup("err"));
			break;
	}
	return str;
}

void compileAST(TreeNode* head, char ** parts){
	int i;
	switch(head->label){
		case TN_HEAD:
			if(head->numChildren != 0) compileAST(head->children[0], parts);
			break;
		case TN_PROGRAM:
			concat(COMPILE_PART_PREMAIN, strdup("//This is autogenerated by the Charm Compiler.\n"));
			if(head->numChildren != 0) compileAST(head->children[0], parts);
			break;
		case TN_STMTLIST:
			for(i = 0; i < head->numChildren; i ++) compileAST(head->children[i], parts);
			break;
		case TN_STMT:
			for(i = 0; i < head->numChildren; i ++) compileAST(head->children[i], parts);
			break;
		case TN_EXPRESSION:
			for(i = 0; i < head->numChildren; i ++) compileAST(head->children[i], parts);
			break;
		case TN_ASSIGN:
			concat(COMPILE_PART_MAIN, strdup("//A variable is being assigned!\n"));
			TreeNode *identifier = head->children[0];
			TreeNode *expression = head->children[0];
			Variable *variable = createVariable(head, identifier, expression);
			concat(COMPILE_PART_MAIN, variableToString(variable));
			free(variable);
			break;
		default:
			break;
	}
}

void compile(FILE* file, TreeNode* head){
	Hashmap* lookupTable = generateHashmap();

	// We create a list of the pointers describing the parts of the file.
	// This serves to allow for reallocation of individual pointers, so that we can
	// append the arrays more characters as needed.
	// Individual functions can add content to either section -- premain or main.
	// Eventually, we may have .h files, and as such can simply expand this array and all
	// will be well.
	char ** parts = malloc(sizeof(char*) * 2);
	parts[COMPILE_PART_PREMAIN] = malloc(1 * sizeof(char));
	parts[COMPILE_PART_PREMAIN][0] = '\0';
	parts[COMPILE_PART_MAIN] = malloc(1 * sizeof(char));
	parts[COMPILE_PART_MAIN][0] = '\0';

	// Now we can do compilation.
	// This is done by traversing the AST and, at each step, the function will output (maybe)
	// some content into a part. At the end of compilation, we can output these variables in the correct
	// spots. 
	compileAST(head, parts);

	fprintf(file, "#include <stdlib.h>\n");
	fprintf(file, "%s\n", parts[COMPILE_PART_PREMAIN]);

	fprintf(file, "int main(){\n");
	fprintf(file, "%s\n", parts[COMPILE_PART_MAIN]);
	fprintf(file, "return 0;\n");
	fprintf(file, "}\n");

	destroyHashmap(lookupTable);
}
