#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "compiler.h"
#include "parser.h"
#include "lexer.h"
#include "io.h"
#include "hashmap.h"

#define COMPILE_PART_PREMAIN 0
#define COMPILE_PART_MAIN 1

#define concat(A, B) {parts[A] = appendString(parts[A], B);}

void compileAST(TreeNode* head, char ** parts){
	switch(head->label){
		case TN_HEAD:
			if(head->numChildren != 0) compileAST(head->children[0], parts);
			break;
		case TN_PROGRAM:
			concat(COMPILE_PART_PREMAIN, strdup("//This is autogenerated by the Charm Compiler."));
			if(head->numChildren != 0) compileAST(head->children[0], parts);
			break;
		default:
			break;
	}
}

void compile(FILE* file, TreeNode* head){
	Hashmap* lookupTable = generateHashmap();

	// We create a list of the pointers describing the parts of the file.
	// This serves to allow for reallocation of individual pointers, so that we can
	// append the arrays more characters as needed.
	// Individual functions can add content to either section -- premain or main.
	// Eventually, we may have .h files, and as such can simply expand this array and all
	// will be well.
	char ** parts = malloc(sizeof(char*) * 2);
	parts[COMPILE_PART_PREMAIN] = malloc(1 * sizeof(char));
	parts[COMPILE_PART_PREMAIN][0] = '\0';
	parts[COMPILE_PART_MAIN] = malloc(1 * sizeof(char));
	parts[COMPILE_PART_MAIN][0] = '\0';

	// Now we can do compilation.
	// This is done by traversing the AST and, at each step, the function will output (maybe)
	// some content into a part. At the end of compilation, we can output these variables in the correct
	// spots. 
	compileAST(head, parts);

	fprintf(file, "#include <stdlib.h>\n");
	fprintf(file, "%s\n", parts[COMPILE_PART_PREMAIN]);

	fprintf(file, "int main(){\n");
	fprintf(file, "%s\n", parts[COMPILE_PART_MAIN]);
	fprintf(file, "return 0;\n");
	fprintf(file, "}\n");

	destroyHashmap(lookupTable);
}
